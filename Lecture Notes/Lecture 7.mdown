#Lecture 5: Machine-Level Programming V: Advanced Topics


Bug Example:
```C
typedef struct {
	int a[2];
	double d;
} struct_t;

double fun(int i) {
	volatile struct_t a;
	s.d = 3.14;
	s.a[i] = 1073741824; //possibly out of bounds
	return s.d;
}
```

if call fun(6), it gives us a __segmentation fault__
To exceed the capacity of the memory allocated is called 
a "Buffer Overflow"
this is the #1 technical cause of security vulnerabilities 
#1 overall cause is social engineering / user ignorance

Most Common Form: 
Unchecked lengths on string inputs 
particularly for bounded character arrays on the stack 
	Sometimes referred to as stack smashing

```C
//Get string from stdin
char *gets(char *dest)
{
	int c = getchar();
	char *p = dest;
	while (c != EOF && c != '\n') {
		*p++ = c;
		c = getchar();
	}
	*p = '\0';
	return dest;
}
```
There is no way to specify limit on number of characters to read 
Similar problems with other library functions:
__strcpy, strcat,__
__scanf, fscanf, sscanf__

Vulnerable Buffer Code

```C
void echo()
{
	char buf[4];   //way to small 
	gets(buf);
	puts(buf);
}

int main(int argc, char* argv[ ])
{
	echo();
	return 0;
}
```

If the inputs are 3 chars long, then there is no problem,
however if inputs exceed the 4 char limit, we get a Segmentation Fault
Now, Debug with gdb 


```shell
gdb testbuff
(gdb)break main
(gdb)dsassemble main 
```



##Union

Allocate according to largest element 
Can only use one field at a time 

```C
union U1 {
	char c;
	int i[2];
	double v; 
} *up;
```
```C
struct S1 {
	char c;
	int i[2];
	double v;
} *sp;
```
Union vs Struct; while the memory allocation for a struct is linear 
Union is more like a stack way of storing memory 

###Accessing Bit Patterns
```C
typedef union {
	float f;
	unsigned u;
}bit_float_t;
```
|----|
| U  |
|----|
| f  |
|----|
0    4 

```C
float bit2float(unsigned u)
{
	bit_float_t arg;
	arg.u = u;
	return arg.f; 
}
```
```C
unsigned float2bit (float f)
{
	bit_float_t arg;
	arg.f = f;
	return arg.u;
}
```
same 64 bits viewed in 2 different ways 
returned result of bit2float and float2bit:
not the same, even they have the same memory address 
however, we can't use different elements in a union at once
revising a value in union will affect others 

###Byte Ordering 

Big Endian : 	Most significant byte has lowest address 

Little Endian : 	Least significant byte has lowest address
(x86, ARM Android, iOS)

Bi Endian : ARM

```C
union {
	unsigned char c[8];
	unsigned short s[4];
	unsigned int i[2];
	unsigned long l[1];
} dw;
```





































