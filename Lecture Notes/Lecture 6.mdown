#Lecture 6: Machine Level Data Structure

##Array Allocation 
__Basic Principle__
T A[L]
array of data type T and length L
contiguously allocated region of L * sizeof(T) bytes in memory 

Array Example:
```C
#define ZLEN 5
typedef int zip_dig[ZLEN];
zip_dig cmu = {1, 5, 2, 1, 3};
zip_dig mit = {0, 2, 1, 3, 9};
zip_dig ucb = {9, 4, 7, 2, 0};
```
between each int, there is a 4 byte difference in memory 
in each array, values are stored in sucessive 20 byte blocks 

__Array Accessing__

```C
int get_digit (zip_dig z, int digit)
{
	return z[digit];
}
```
%rdi contains starting address of array
%rsi contains array index
desired digit at %rdi + 4 * %rsi
use memory reference (%rdi, %rsi, 4)

%rdi = z 
%rsi = digit
%eax = z[digit]

```Assembly
movl (%rdi, %rsi, 4), %eax 
```
__Array Loop__

```C
void zincr(zip_dig z)
{
	size_t i;
	for (i = 0; i < ZLEN; i++)
	{ 
		z[i]++;
	}
}
```
%rdi = z

```Assembly
	movl	$0, %eax 			# i = 0 
	jmp 	.L3 				#goto middle 
.L4:
	addl 	$1, ($rdi, %rax, 4)  #Z[i]++
	addq 	$1, %rax 			 # i++
.L3:
	cmpq 	$4, %rax 			 # i : 4
	jbe     .L4 				 # if <=, goto loop
	rep; ret 
```

##Nested Arrays 

```C
#define PCOUNT 4 
zip_dig pgh[PCOUNT] = 
   {{1, 5, 2, 0, 6},
	{1, 5, 2, 1, 3},
	{2, 3, 4, 5, 6},
	{3, 1, 4, 1, 5}};
```

zip_dig pgh[4] equivalent to int pgh[4][5]
both are 2 dimensional arrays 

###Nested Array Row Access
A[i] is array of C elements 
Each element of type T requires K bytes 
starting address: A + i * (C * K)

```C
int *get_pgh_zip(int index)
{
	return pgh[index];
}
```
%rdi = index
```Assembly
leaq (%rdi, %rdi, 4), %rax   # 5 * index
leaq pgh(, %rax, 4), %rax    # pgh + (20 * index)
```
the machine code computes as pgh + 4 * (4 * index) + 4 * index

###Nested Array Element Access
A[i][j] is the element of type T, which requires K bytes 
Address A + K(i*C + j)

```C
int get_pgh_digit
{
	return pgh[index][dig];
}
```
%rdi is index
%rsi is dig

```Assembly 
leaq (%rdi, %rdi, 4), %rax    # 5 * index
addl %rax, %rsi  			  # 5 * index + dig 
movl pgh(, %rsi, 4), %eax     # M[pgh + 4 * (5*index + dig)]
```

###Multi-Level Array Example 

```C
zip_dig cmu = {1, 5, 2, 1, 3};
zip_dig mit = {0, 2, 1, 3, 9};
zip_dig ucb = {9, 4, 7, 2, 0};
#define UCOUNT = 3
int *univ[UCOUNT] = {mit, cmu, ucb}
```
each element of univ is a pointer with 8 bytes memory 
each pointer points to an array of ints 

```C
int get_univ_digit (size_t index, size_t digit)
{
	return univ[index][digit];
}
```
%rsi is digit
%rdi is index
```Assembly 
salq $2, %rsi 				# 4 * digit
addq univ(, %rdi, 8), %rsi  # p = univ[index] + 4 * digit
movl (%rsi), %eax 			# return *p
ret 
```
Element access Mem[Mem[univ + 8 * index] + 4 * digit]
must do two memory reads
first get pointer to row array 
then access element within array 


##Structures 

Structures are represented as block of memory 
Fields ordered according to declacation 
Compiler determines overall size + position of fields 

```C
struct rec {
	int a[4];
	size_t i;
	struct rec *next;
};
```
```C
int *get_ap (struct rec *r, size_t idx)
{
	return &r->a[idx];
}
```
%rdi : r 
%rsi : idx 
```Assembly
leaq (%rdi, %rsi, 4), %rax 
ret 
```

 r 	r+4*idx    
------------------------
|a 			|  i | next|
------------------------
offset of each structure member determined at compile time 
compute as r + 4*idr 

__Following a linked List__

```C
void set_val (struct rec *r, int val)
{
	while(r) {
		int i = r -> i;
		r -> a[i] = val;
		r = r -> next;
	}
}
```

%rdi : r 
%rsi : val 

```Assembly 
.L11:
	movslq 	16(%rdi), %rax   #i = M[r+16], since r has 16 bytes
	movl 	%esi, (%rdi, %rax, 4)
	movq 	24(%rdi), %rdi   # r = M[r+24], r = r->next
	testq 	%rdi, %rdi       # test if r == 0
	jne 	.L11 			 # if !=0 goto loop 
```









